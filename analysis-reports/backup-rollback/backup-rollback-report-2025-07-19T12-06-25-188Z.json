{
  "title": "RLS Policy Backup and Rollback System",
  "generated_at": "2025-07-19T12:06:25.181Z",
  "purpose": "Comprehensive backup and recovery system for RLS policy optimization",
  "components": {
    "backup_procedures": {
      "description": "Automated and manual backup procedures",
      "procedures": {
        "full_policy_backup": "\n        -- RLS Policy Backup Script\n        -- Generated: 2025-07-19T12:06:25.189Z\n        -- This script exports all current RLS policy definitions for backup\n        \n        -- Create backup table to store policy definitions\n        CREATE TABLE IF NOT EXISTS rls_policy_backup_2025-07-19T12_06_25_189Z (\n          backup_id SERIAL PRIMARY KEY,\n          backup_timestamp TIMESTAMPTZ DEFAULT NOW(),\n          schema_name TEXT NOT NULL,\n          table_name TEXT NOT NULL,\n          policy_name TEXT NOT NULL,\n          policy_command TEXT NOT NULL,\n          policy_permissive TEXT,\n          policy_roles TEXT[],\n          policy_qual TEXT,\n          policy_with_check TEXT,\n          backup_reason TEXT DEFAULT 'pre_optimization_backup'\n        );\n        \n        -- Insert all current policies into backup table\n        INSERT INTO rls_policy_backup_2025-07-19T12_06_25_189Z \n        (schema_name, table_name, policy_name, policy_command, policy_permissive, policy_roles, policy_qual, policy_with_check)\n        SELECT \n          schemaname,\n          tablename,\n          policyname,\n          cmd,\n          permissive,\n          roles,\n          qual,\n          with_check\n        FROM pg_policies \n        WHERE schemaname = 'public'\n        ORDER BY tablename, policyname;\n      ",
        "auth_policies_backup": "\n        -- Backup Only Policies with Auth Function Calls\n        -- This creates a focused backup of policies that will be optimized\n        \n        SELECT \n          'CREATE POLICY ' || quote_ident(policyname) || ' ON ' || quote_ident(tablename) ||\n          CASE \n            WHEN permissive = 'PERMISSIVE' THEN ' AS PERMISSIVE'\n            WHEN permissive = 'RESTRICTIVE' THEN ' AS RESTRICTIVE'\n            ELSE ''\n          END ||\n          ' FOR ' || cmd ||\n          CASE \n            WHEN roles IS NOT NULL AND array_length(roles, 1) > 0 \n            THEN ' TO ' || array_to_string(roles, ', ')\n            ELSE ''\n          END ||\n          CASE \n            WHEN qual IS NOT NULL \n            THEN ' USING (' || qual || ')'\n            ELSE ''\n          END ||\n          CASE \n            WHEN with_check IS NOT NULL \n            THEN ' WITH CHECK (' || with_check || ')'\n            ELSE ''\n          END || ';' as backup_sql\n        FROM pg_policies \n        WHERE schemaname = 'public'\n        AND (\n          qual LIKE '%auth.uid()%' OR \n          qual LIKE '%auth.jwt()%' OR\n          with_check LIKE '%auth.uid()%' OR\n          with_check LIKE '%auth.jwt()%'\n        )\n        ORDER BY tablename, policyname;\n      ",
        "pre_optimization_backup": "\n        -- Automated Pre-Optimization Backup Procedure\n        -- Run this before any RLS policy optimization\n        \n        DO $$\n        DECLARE\n          backup_table_name TEXT;\n          backup_count INTEGER;\n          policies_to_backup INTEGER;\n        BEGIN\n          -- Generate unique backup table name\n          backup_table_name := 'rls_backup_' || to_char(NOW(), 'YYYY_MM_DD_HH24_MI_SS');\n          \n          -- Count policies that will be backed up\n          SELECT COUNT(*) INTO policies_to_backup\n          FROM pg_policies \n          WHERE schemaname = 'public'\n          AND (\n            qual LIKE '%auth.uid()%' OR \n            qual LIKE '%auth.jwt()%' OR\n            with_check LIKE '%auth.uid()%' OR\n            with_check LIKE '%auth.jwt()%'\n          );\n          \n          -- Create backup table\n          EXECUTE format('\n            CREATE TABLE %I (\n              backup_id SERIAL PRIMARY KEY,\n              backup_timestamp TIMESTAMPTZ DEFAULT NOW(),\n              schema_name TEXT NOT NULL,\n              table_name TEXT NOT NULL,\n              policy_name TEXT NOT NULL,\n              policy_command TEXT NOT NULL,\n              policy_permissive TEXT,\n              policy_roles TEXT[],\n              policy_qual TEXT,\n              policy_with_check TEXT,\n              original_policy_sql TEXT,\n              backup_reason TEXT DEFAULT ''pre_optimization_backup''\n            )', backup_table_name);\n          \n          -- Insert policies into backup table with reconstructed SQL\n          EXECUTE format('\n            INSERT INTO %I \n            (schema_name, table_name, policy_name, policy_command, policy_permissive, \n             policy_roles, policy_qual, policy_with_check, original_policy_sql)\n            SELECT \n              schemaname,\n              tablename,\n              policyname,\n              cmd,\n              permissive,\n              roles,\n              qual,\n              with_check,\n              ''DROP POLICY IF EXISTS '' || quote_ident(policyname) || '' ON '' || quote_ident(tablename) || '';'' ||\n              E''\n'' ||\n              ''CREATE POLICY '' || quote_ident(policyname) || '' ON '' || quote_ident(tablename) ||\n              CASE \n                WHEN permissive = ''PERMISSIVE'' THEN '' AS PERMISSIVE''\n                WHEN permissive = ''RESTRICTIVE'' THEN '' AS RESTRICTIVE''\n                ELSE ''''\n              END ||\n              '' FOR '' || cmd ||\n              CASE \n                WHEN roles IS NOT NULL AND array_length(roles, 1) > 0 \n                THEN '' TO '' || array_to_string(roles, '', '')\n                ELSE ''''\n              END ||\n              CASE \n                WHEN qual IS NOT NULL \n                THEN '' USING ('' || qual || '')''\n                ELSE ''''\n              END ||\n              CASE \n                WHEN with_check IS NOT NULL \n                THEN '' WITH CHECK ('' || with_check || '')''\n                ELSE ''''\n              END || '';''\n            FROM pg_policies \n            WHERE schemaname = ''public''\n            AND (\n              qual LIKE ''%%auth.uid()%%'' OR \n              qual LIKE ''%%auth.jwt()%%'' OR\n              with_check LIKE ''%%auth.uid()%%'' OR\n              with_check LIKE ''%%auth.jwt()%%''\n            )', backup_table_name);\n          \n          -- Verify backup was created successfully\n          EXECUTE format('SELECT COUNT(*) FROM %I', backup_table_name) INTO backup_count;\n          \n          IF backup_count != policies_to_backup THEN\n            RAISE EXCEPTION 'Backup verification failed: Expected % policies, backed up %', \n              policies_to_backup, backup_count;\n          END IF;\n          \n          RAISE NOTICE 'SUCCESS: Backed up % RLS policies to table %', backup_count, backup_table_name;\n          RAISE NOTICE 'Backup table: %', backup_table_name;\n        END $$;\n      ",
        "table_specific_backup": "\n        -- Table-Specific Backup Procedure\n        -- Use this to backup policies for a specific table before optimization\n        \n        CREATE OR REPLACE FUNCTION backup_table_policies(p_table_name TEXT)\n        RETURNS TEXT AS $$\n        DECLARE\n          backup_table_name TEXT;\n          backup_count INTEGER;\n          result_message TEXT;\n        BEGIN\n          -- Generate backup table name\n          backup_table_name := 'rls_backup_' || p_table_name || '_' || to_char(NOW(), 'YYYY_MM_DD_HH24_MI_SS');\n          \n          -- Create backup table for this specific table\n          EXECUTE format('\n            CREATE TABLE %I (\n              backup_id SERIAL PRIMARY KEY,\n              backup_timestamp TIMESTAMPTZ DEFAULT NOW(),\n              table_name TEXT NOT NULL,\n              policy_name TEXT NOT NULL,\n              policy_sql TEXT NOT NULL,\n              backup_reason TEXT DEFAULT ''table_specific_backup''\n            )', backup_table_name);\n          \n          -- Backup policies for the specified table\n          EXECUTE format('\n            INSERT INTO %I (table_name, policy_name, policy_sql)\n            SELECT \n              tablename,\n              policyname,\n              ''DROP POLICY IF EXISTS '' || quote_ident(policyname) || '' ON '' || quote_ident(tablename) || '';'' ||\n              E''\n'' ||\n              ''CREATE POLICY '' || quote_ident(policyname) || '' ON '' || quote_ident(tablename) ||\n              CASE \n                WHEN permissive = ''PERMISSIVE'' THEN '' AS PERMISSIVE''\n                WHEN permissive = ''RESTRICTIVE'' THEN '' AS RESTRICTIVE''\n                ELSE ''''\n              END ||\n              '' FOR '' || cmd ||\n              CASE \n                WHEN roles IS NOT NULL AND array_length(roles, 1) > 0 \n                THEN '' TO '' || array_to_string(roles, '', '')\n                ELSE ''''\n              END ||\n              CASE \n                WHEN qual IS NOT NULL \n                THEN '' USING ('' || qual || '')''\n                ELSE ''''\n              END ||\n              CASE \n                WHEN with_check IS NOT NULL \n                THEN '' WITH CHECK ('' || with_check || '')''\n                ELSE ''''\n              END || '';''\n            FROM pg_policies \n            WHERE schemaname = ''public''\n            AND tablename = %L', backup_table_name, p_table_name);\n          \n          -- Get backup count\n          EXECUTE format('SELECT COUNT(*) FROM %I', backup_table_name) INTO backup_count;\n          \n          result_message := format('Backed up %s policies for table %s to %s', \n            backup_count, p_table_name, backup_table_name);\n          \n          RETURN result_message;\n        END $$ LANGUAGE plpgsql;\n      "
      }
    },
    "rollback_scripts": {
      "description": "Automated rollback procedures for failed optimizations",
      "scripts": {
        "complete_rollback": "\n        -- Complete Rollback from Backup Table\n        -- Use this to restore all policies from a backup table\n        \n        CREATE OR REPLACE FUNCTION rollback_from_backup(p_backup_table_name TEXT)\n        RETURNS TEXT AS $$\n        DECLARE\n          policy_record RECORD;\n          rollback_count INTEGER := 0;\n          error_count INTEGER := 0;\n          result_message TEXT;\n        BEGIN\n          -- Verify backup table exists\n          IF NOT EXISTS (\n            SELECT 1 FROM information_schema.tables \n            WHERE table_name = p_backup_table_name\n          ) THEN\n            RAISE EXCEPTION 'Backup table % does not exist', p_backup_table_name;\n          END IF;\n          \n          -- Process each policy in the backup\n          FOR policy_record IN \n            EXECUTE format('SELECT * FROM %I ORDER BY table_name, policy_name', p_backup_table_name)\n          LOOP\n            BEGIN\n              -- Execute the original policy SQL to restore it\n              EXECUTE policy_record.original_policy_sql;\n              rollback_count := rollback_count + 1;\n              \n              RAISE NOTICE 'Restored policy: %.%', \n                policy_record.table_name, policy_record.policy_name;\n                \n            EXCEPTION\n              WHEN OTHERS THEN\n                error_count := error_count + 1;\n                RAISE WARNING 'Failed to restore policy %.%: %', \n                  policy_record.table_name, policy_record.policy_name, SQLERRM;\n            END;\n          END LOOP;\n          \n          result_message := format('Rollback complete: %s policies restored, %s errors', \n            rollback_count, error_count);\n          \n          RETURN result_message;\n        END $$ LANGUAGE plpgsql;\n      ",
        "selective_rollback": "\n        -- Selective Rollback for Specific Tables\n        -- Use this to rollback only specific tables from a backup\n        \n        CREATE OR REPLACE FUNCTION rollback_table_from_backup(\n          p_backup_table_name TEXT,\n          p_target_table_name TEXT\n        )\n        RETURNS TEXT AS $$\n        DECLARE\n          policy_record RECORD;\n          rollback_count INTEGER := 0;\n          error_count INTEGER := 0;\n          result_message TEXT;\n        BEGIN\n          -- Process policies for the specific table\n          FOR policy_record IN \n            EXECUTE format('\n              SELECT * FROM %I \n              WHERE table_name = %L \n              ORDER BY policy_name', \n              p_backup_table_name, p_target_table_name)\n          LOOP\n            BEGIN\n              -- Execute the original policy SQL to restore it\n              EXECUTE policy_record.original_policy_sql;\n              rollback_count := rollback_count + 1;\n              \n              RAISE NOTICE 'Restored policy: %.%', \n                policy_record.table_name, policy_record.policy_name;\n                \n            EXCEPTION\n              WHEN OTHERS THEN\n                error_count := error_count + 1;\n                RAISE WARNING 'Failed to restore policy %.%: %', \n                  policy_record.table_name, policy_record.policy_name, SQLERRM;\n            END;\n          END LOOP;\n          \n          IF rollback_count = 0 THEN\n            RAISE WARNING 'No policies found for table % in backup %', \n              p_target_table_name, p_backup_table_name;\n          END IF;\n          \n          result_message := format('Table rollback complete: %s policies restored for %s, %s errors', \n            rollback_count, p_target_table_name, error_count);\n          \n          RETURN result_message;\n        END $$ LANGUAGE plpgsql;\n      ",
        "emergency_rollback": "\n        -- Emergency Rollback Procedure\n        -- Use this for immediate rollback when optimization causes issues\n        \n        CREATE OR REPLACE FUNCTION emergency_rollback()\n        RETURNS TEXT AS $$\n        DECLARE\n          latest_backup_table TEXT;\n          rollback_result TEXT;\n        BEGIN\n          -- Find the most recent backup table\n          SELECT table_name INTO latest_backup_table\n          FROM information_schema.tables \n          WHERE table_name LIKE 'rls_backup_%'\n          AND table_schema = 'public'\n          ORDER BY table_name DESC\n          LIMIT 1;\n          \n          IF latest_backup_table IS NULL THEN\n            RAISE EXCEPTION 'No backup tables found for emergency rollback';\n          END IF;\n          \n          RAISE NOTICE 'Emergency rollback using backup table: %', latest_backup_table;\n          \n          -- Execute complete rollback\n          SELECT rollback_from_backup(latest_backup_table) INTO rollback_result;\n          \n          RETURN format('Emergency rollback completed using %s: %s', \n            latest_backup_table, rollback_result);\n        END $$ LANGUAGE plpgsql;\n      "
      }
    },
    "verification_procedures": {
      "description": "Procedures to verify successful rollback operations",
      "procedures": {
        "verify_rollback_success": "\n        -- Rollback Verification Procedure\n        -- Verifies that policies were successfully restored to their original state\n        \n        CREATE OR REPLACE FUNCTION verify_rollback_success(p_backup_table_name TEXT)\n        RETURNS TABLE (\n          table_name TEXT,\n          policy_name TEXT,\n          rollback_status TEXT,\n          current_qual TEXT,\n          backup_qual TEXT,\n          verification_result TEXT\n        ) AS $$\n        BEGIN\n          RETURN QUERY\n          EXECUTE format('\n            SELECT \n              b.table_name::TEXT,\n              b.policy_name::TEXT,\n              CASE \n                WHEN p.policyname IS NOT NULL THEN ''POLICY_EXISTS''\n                ELSE ''POLICY_MISSING''\n              END::TEXT as rollback_status,\n              p.qual::TEXT as current_qual,\n              b.policy_qual::TEXT as backup_qual,\n              CASE \n                WHEN p.policyname IS NULL THEN ''❌ ROLLBACK_FAILED''\n                WHEN p.qual = b.policy_qual THEN ''✅ ROLLBACK_SUCCESS''\n                WHEN p.qual != b.policy_qual THEN ''⚠️ ROLLBACK_PARTIAL''\n                ELSE ''❓ ROLLBACK_UNKNOWN''\n              END::TEXT as verification_result\n            FROM %I b\n            LEFT JOIN pg_policies p ON (\n              p.schemaname = ''public'' \n              AND p.tablename = b.table_name \n              AND p.policyname = b.policy_name\n            )\n            ORDER BY b.table_name, b.policy_name', p_backup_table_name);\n        END $$ LANGUAGE plpgsql;\n      ",
        "compare_with_backup": "\n        -- Compare Current Policies with Backup\n        -- Detailed comparison to verify rollback accuracy\n        \n        CREATE OR REPLACE FUNCTION compare_policies_with_backup(p_backup_table_name TEXT)\n        RETURNS TABLE (\n          comparison_type TEXT,\n          table_name TEXT,\n          policy_name TEXT,\n          field_name TEXT,\n          current_value TEXT,\n          backup_value TEXT,\n          match_status TEXT\n        ) AS $$\n        BEGIN\n          RETURN QUERY\n          EXECUTE format('\n            WITH policy_comparison AS (\n              SELECT \n                b.table_name,\n                b.policy_name,\n                p.qual as current_qual,\n                b.policy_qual as backup_qual,\n                p.with_check as current_with_check,\n                b.policy_with_check as backup_with_check,\n                p.cmd as current_cmd,\n                b.policy_command as backup_cmd\n              FROM %I b\n              LEFT JOIN pg_policies p ON (\n                p.schemaname = ''public'' \n                AND p.tablename = b.table_name \n                AND p.policyname = b.policy_name\n              )\n            )\n            SELECT \n              ''QUAL_COMPARISON''::TEXT,\n              table_name::TEXT,\n              policy_name::TEXT,\n              ''qual''::TEXT,\n              current_qual::TEXT,\n              backup_qual::TEXT,\n              CASE \n                WHEN current_qual = backup_qual THEN ''✅ MATCH''\n                WHEN current_qual IS NULL AND backup_qual IS NULL THEN ''✅ MATCH''\n                ELSE ''❌ MISMATCH''\n              END::TEXT\n            FROM policy_comparison\n            WHERE current_qual IS DISTINCT FROM backup_qual\n            \n            UNION ALL\n            \n            SELECT \n              ''WITH_CHECK_COMPARISON''::TEXT,\n              table_name::TEXT,\n              policy_name::TEXT,\n              ''with_check''::TEXT,\n              current_with_check::TEXT,\n              backup_with_check::TEXT,\n              CASE \n                WHEN current_with_check = backup_with_check THEN ''✅ MATCH''\n                WHEN current_with_check IS NULL AND backup_with_check IS NULL THEN ''✅ MATCH''\n                ELSE ''❌ MISMATCH''\n              END::TEXT\n            FROM policy_comparison\n            WHERE current_with_check IS DISTINCT FROM backup_with_check\n            \n            ORDER BY table_name, policy_name, field_name', p_backup_table_name);\n        END $$ LANGUAGE plpgsql;\n      "
      }
    },
    "manual_recovery": {
      "description": "Manual recovery procedures for complex failure scenarios",
      "procedures": {
        "manual_recovery_guide": "\n        -- Manual Recovery Procedures for Complex Failures\n        -- Use these procedures when automated rollback fails\n        \n        /*\n        MANUAL RECOVERY PROCEDURE 1: Partial Rollback Failure\n        \n        When some policies fail to rollback automatically:\n        \n        1. Identify failed policies:\n           SELECT * FROM verify_rollback_success('your_backup_table_name')\n           WHERE verification_result LIKE '%FAILED%';\n        \n        2. For each failed policy, manually execute:\n           -- Drop the current (potentially corrupted) policy\n           DROP POLICY IF EXISTS \"policy_name\" ON \"table_name\";\n           \n           -- Recreate from backup (get SQL from backup table)\n           SELECT original_policy_sql FROM your_backup_table_name \n           WHERE table_name = 'your_table' AND policy_name = 'your_policy';\n           \n           -- Execute the returned SQL\n        \n        3. Verify the manual fix:\n           SELECT * FROM verify_rollback_success('your_backup_table_name')\n           WHERE table_name = 'your_table' AND policy_name = 'your_policy';\n        */\n        \n        /*\n        MANUAL RECOVERY PROCEDURE 2: Complete System Recovery\n        \n        When the entire optimization needs to be reversed:\n        \n        1. List all backup tables:\n           SELECT table_name FROM information_schema.tables \n           WHERE table_name LIKE 'rls_backup_%' \n           ORDER BY table_name DESC;\n        \n        2. Choose the appropriate backup (usually the most recent):\n           -- Use the latest backup for complete recovery\n           \n        3. Execute emergency rollback:\n           SELECT emergency_rollback();\n        \n        4. If emergency rollback fails, manual restoration:\n           -- Get all policy SQL from backup\n           SELECT table_name, policy_name, original_policy_sql \n           FROM your_backup_table_name \n           ORDER BY table_name, policy_name;\n           \n           -- Execute each original_policy_sql statement manually\n        \n        5. Verify complete recovery:\n           SELECT * FROM verify_rollback_success('your_backup_table_name');\n        */\n        \n        /*\n        MANUAL RECOVERY PROCEDURE 3: Backup Table Recovery\n        \n        When backup tables are corrupted or missing:\n        \n        1. Check for alternative backups:\n           -- Look for file-based backups in analysis-reports/\n           -- Check for database dumps\n           -- Look for version control history\n        \n        2. If no backups available, reconstruct policies:\n           -- Review application code for expected RLS behavior\n           -- Check documentation for policy requirements\n           -- Recreate policies based on security requirements\n        \n        3. Test reconstructed policies thoroughly:\n           -- Use security verification tests\n           -- Verify user access patterns\n           -- Test role-based access controls\n        */\n        \n        SELECT 'Manual recovery procedures loaded. See comments for detailed instructions.' as status;\n      ",
        "recovery_validation_checklist": "\n        -- Recovery Validation Checklist\n        -- Use this checklist to verify successful recovery\n        \n        CREATE OR REPLACE FUNCTION recovery_validation_checklist()\n        RETURNS TABLE (\n          check_category TEXT,\n          check_description TEXT,\n          check_status TEXT,\n          check_result TEXT,\n          action_required TEXT\n        ) AS $$\n        DECLARE\n          total_policies INTEGER;\n          policies_with_auth INTEGER;\n          optimized_policies INTEGER;\n          unoptimized_policies INTEGER;\n        BEGIN\n          -- Get policy counts\n          SELECT COUNT(*) INTO total_policies\n          FROM pg_policies WHERE schemaname = 'public';\n          \n          SELECT COUNT(*) INTO policies_with_auth\n          FROM pg_policies \n          WHERE schemaname = 'public'\n          AND (qual LIKE '%auth.uid()%' OR qual LIKE '%auth.jwt()%' OR\n               with_check LIKE '%auth.uid()%' OR with_check LIKE '%auth.jwt()%');\n          \n          SELECT COUNT(*) INTO optimized_policies\n          FROM pg_policies \n          WHERE schemaname = 'public'\n          AND (qual LIKE '%(SELECT auth.uid())%' OR qual LIKE '%(SELECT auth.jwt())%' OR\n               with_check LIKE '%(SELECT auth.uid())%' OR with_check LIKE '%(SELECT auth.jwt())%');\n          \n          SELECT COUNT(*) INTO unoptimized_policies\n          FROM pg_policies \n          WHERE schemaname = 'public'\n          AND ((qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(SELECT auth.uid())%') OR\n               (qual LIKE '%auth.jwt()%' AND qual NOT LIKE '%(SELECT auth.jwt())%') OR\n               (with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(SELECT auth.uid())%') OR\n               (with_check LIKE '%auth.jwt()%' AND with_check NOT LIKE '%(SELECT auth.jwt())%'));\n          \n          -- Return validation results\n          RETURN QUERY VALUES\n            ('POLICY_COUNT', 'Total RLS policies exist', \n             CASE WHEN total_policies > 0 THEN '✅ PASS' ELSE '❌ FAIL' END,\n             total_policies::TEXT || ' policies found',\n             CASE WHEN total_policies = 0 THEN 'Restore policies from backup' ELSE 'None' END),\n            \n            ('AUTH_POLICIES', 'Policies with auth functions exist', \n             CASE WHEN policies_with_auth > 0 THEN '✅ PASS' ELSE '⚠️ WARNING' END,\n             policies_with_auth::TEXT || ' policies with auth functions',\n             CASE WHEN policies_with_auth = 0 THEN 'Verify if auth policies should exist' ELSE 'None' END),\n            \n            ('OPTIMIZATION_STATUS', 'Check optimization state after recovery', \n             CASE \n               WHEN unoptimized_policies = 0 AND optimized_policies > 0 THEN '⚠️ STILL_OPTIMIZED'\n               WHEN unoptimized_policies > 0 AND optimized_policies = 0 THEN '✅ ROLLBACK_SUCCESS'\n               WHEN unoptimized_policies > 0 AND optimized_policies > 0 THEN '⚠️ MIXED_STATE'\n               ELSE '❓ UNKNOWN'\n             END,\n             'Optimized: ' || optimized_policies::TEXT || ', Unoptimized: ' || unoptimized_policies::TEXT,\n             CASE \n               WHEN unoptimized_policies = 0 AND optimized_policies > 0 THEN 'Rollback may not have completed'\n               WHEN unoptimized_policies > 0 AND optimized_policies > 0 THEN 'Some policies may need manual rollback'\n               ELSE 'None'\n             END);\n        END $$ LANGUAGE plpgsql;\n      "
      }
    }
  },
  "usage_workflow": {
    "before_optimization": [
      "Execute pre-optimization backup procedure",
      "Verify backup table was created successfully",
      "Store backup table name for potential rollback"
    ],
    "during_optimization": [
      "Monitor optimization progress",
      "Check for any errors or failures",
      "Be prepared to execute emergency rollback if needed"
    ],
    "after_optimization": [
      "Verify optimization completed successfully",
      "Test optimized policies work correctly",
      "Keep backup tables for safety period before cleanup"
    ],
    "rollback_if_needed": [
      "Execute appropriate rollback procedure",
      "Verify rollback completed successfully",
      "Run recovery validation checklist",
      "Document rollback reason and resolution"
    ]
  },
  "patterns_for_future_agents": {
    "backup_before_changes": {
      "description": "Always create backups before making RLS policy changes",
      "pattern": "\n          -- Pattern: Backup Before Changes\n          -- Always execute this before modifying RLS policies\n          \n          DO $$\n          DECLARE\n            backup_table_name TEXT;\n          BEGIN\n            -- Create timestamped backup\n            backup_table_name := 'rls_backup_' || to_char(NOW(), 'YYYY_MM_DD_HH24_MI_SS');\n            \n            -- Execute backup procedure\n            PERFORM backup_table_policies('your_table_name');\n            \n            -- Verify backup success\n            IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = backup_table_name) THEN\n              RAISE EXCEPTION 'Backup failed - aborting changes';\n            END IF;\n            \n            RAISE NOTICE 'Backup completed: %', backup_table_name;\n          END $$;\n        "
    },
    "rollback_on_failure": {
      "description": "Automatic rollback pattern for failed operations",
      "pattern": "\n          -- Pattern: Rollback on Failure\n          -- Use this pattern to automatically rollback on errors\n          \n          DO $$\n          DECLARE\n            backup_table_name TEXT := 'your_backup_table_name';\n          BEGIN\n            -- Attempt the risky operation\n            BEGIN\n              -- Your RLS policy changes here\n              -- DROP POLICY ...\n              -- CREATE POLICY ...\n              \n              -- Verify the changes worked\n              -- Add verification logic here\n              \n            EXCEPTION\n              WHEN OTHERS THEN\n                -- Rollback on any error\n                RAISE NOTICE 'Error occurred, rolling back: %', SQLERRM;\n                PERFORM rollback_from_backup(backup_table_name);\n                RAISE;\n            END;\n          END $$;\n        "
    },
    "verification_after_changes": {
      "description": "Always verify changes and rollback if verification fails",
      "pattern": "\n          -- Pattern: Verification After Changes\n          -- Verify changes work correctly, rollback if not\n          \n          DO $$\n          DECLARE\n            backup_table_name TEXT := 'your_backup_table_name';\n            verification_passed BOOLEAN := false;\n          BEGIN\n            -- Make your changes first\n            -- ... policy modifications ...\n            \n            -- Verify the changes\n            BEGIN\n              -- Test that policies work as expected\n              -- Add your verification logic here\n              verification_passed := true;\n            EXCEPTION\n              WHEN OTHERS THEN\n                verification_passed := false;\n            END;\n            \n            -- Rollback if verification failed\n            IF NOT verification_passed THEN\n              RAISE NOTICE 'Verification failed, rolling back changes';\n              PERFORM rollback_from_backup(backup_table_name);\n              RAISE EXCEPTION 'Changes rolled back due to verification failure';\n            END IF;\n            \n            RAISE NOTICE 'Changes verified and committed successfully';\n          END $$;\n        "
    }
  },
  "recommendations": [
    {
      "priority": "CRITICAL",
      "action": "Always backup before optimization",
      "description": "Create comprehensive backups before any RLS policy changes",
      "impact": "Enables complete recovery if optimization fails"
    },
    {
      "priority": "HIGH",
      "action": "Test rollback procedures",
      "description": "Regularly test rollback procedures to ensure they work",
      "impact": "Ensures recovery procedures work when needed"
    },
    {
      "priority": "HIGH",
      "action": "Verify rollback success",
      "description": "Always verify that rollback operations completed successfully",
      "impact": "Confirms that system is restored to working state"
    },
    {
      "priority": "MEDIUM",
      "action": "Document backup locations",
      "description": "Maintain clear documentation of backup table names and locations",
      "impact": "Enables quick recovery in emergency situations"
    }
  ]
}