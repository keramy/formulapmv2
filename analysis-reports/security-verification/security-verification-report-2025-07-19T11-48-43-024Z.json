{
  "title": "RLS Security Preservation Verification Report",
  "generated_at": "2025-07-19T11:48:43.011Z",
  "purpose": "Verify that RLS policy optimizations preserve original security behavior",
  "test_categories": {
    "access_pattern_tests": {
      "description": "Tests to verify user access patterns remain unchanged",
      "tests": {
        "user_data_access_test": "\n        -- Security Preservation Test: User Data Access\n        -- This test verifies that users can only access their own data after optimization\n        \n        -- Test Setup: Create test data for multiple users\n        DO $$\n        DECLARE\n          test_user_1 UUID := 'user-1-test-uuid'::UUID;\n          test_user_2 UUID := 'user-2-test-uuid'::UUID;\n          test_table_name TEXT := 'test_table_name'; -- Replace with actual table name\n        BEGIN\n          -- Note: This is a template - adapt for your specific table structure\n          \n          -- Test 1a: Verify user 1 can only see their own records\n          SET request.jwt.claims TO json_build_object('sub', test_user_1, 'role', 'authenticated')::text;\n          \n          -- This query should only return records where user_id = test_user_1\n          -- If optimization broke security, it might return other users' data\n          PERFORM (\n            SELECT COUNT(*) \n            FROM test_table_name \n            WHERE user_id != test_user_1\n          );\n          \n          -- If any records are returned, security is compromised\n          IF FOUND THEN\n            RAISE EXCEPTION 'SECURITY VIOLATION: User can access other users data in %', test_table_name;\n          END IF;\n          \n          -- Test 1b: Verify user 2 can only see their own records\n          SET request.jwt.claims TO json_build_object('sub', test_user_2, 'role', 'authenticated')::text;\n          \n          PERFORM (\n            SELECT COUNT(*) \n            FROM test_table_name \n            WHERE user_id != test_user_2\n          );\n          \n          IF FOUND THEN\n            RAISE EXCEPTION 'SECURITY VIOLATION: User can access other users data in %', test_table_name;\n          END IF;\n          \n          RAISE NOTICE 'SECURITY TEST PASSED: User data access properly isolated in %', test_table_name;\n        END $$;\n      ",
        "role_based_access_test": "\n        -- Security Preservation Test: Role-Based Access\n        -- This test verifies that role-based access controls work correctly after optimization\n        \n        DO $$\n        DECLARE\n          admin_user UUID := 'admin-test-uuid'::UUID;\n          regular_user UUID := 'user-test-uuid'::UUID;\n          test_table_name TEXT := 'test_table_name'; -- Replace with actual table name\n          admin_record_count INTEGER;\n          user_record_count INTEGER;\n        BEGIN\n          -- Test 2a: Admin should see all records (if policy allows)\n          SET request.jwt.claims TO json_build_object(\n            'sub', admin_user, \n            'role', 'admin'\n          )::text;\n          \n          SELECT COUNT(*) INTO admin_record_count FROM test_table_name;\n          \n          -- Test 2b: Regular user should see limited records\n          SET request.jwt.claims TO json_build_object(\n            'sub', regular_user, \n            'role', 'authenticated'\n          )::text;\n          \n          SELECT COUNT(*) INTO user_record_count FROM test_table_name;\n          \n          -- Verify role-based access is working\n          -- (Admin should typically see more records than regular user)\n          IF admin_record_count < user_record_count THEN\n            RAISE WARNING 'POTENTIAL ISSUE: Admin sees fewer records than regular user in %', test_table_name;\n          END IF;\n          \n          RAISE NOTICE 'ROLE ACCESS TEST: Admin sees % records, User sees % records in %', \n            admin_record_count, user_record_count, test_table_name;\n        END $$;\n      ",
        "insert_update_security_test": "\n        -- Security Preservation Test: Insert/Update Security\n        -- This test verifies that users can only insert/update records they should have access to\n        \n        DO $$\n        DECLARE\n          test_user UUID := 'test-user-uuid'::UUID;\n          other_user UUID := 'other-user-uuid'::UUID;\n          test_table_name TEXT := 'test_table_name'; -- Replace with actual table name\n        BEGIN\n          -- Set user context\n          SET request.jwt.claims TO json_build_object('sub', test_user, 'role', 'authenticated')::text;\n          \n          -- Test 3a: User should be able to insert records for themselves\n          BEGIN\n            -- Note: Adapt this INSERT for your table structure\n            -- INSERT INTO test_table_name (user_id, data) VALUES (test_user, 'test data');\n            RAISE NOTICE 'INSERT TEST: User can insert their own records';\n          EXCEPTION\n            WHEN insufficient_privilege THEN\n              RAISE EXCEPTION 'SECURITY ISSUE: User cannot insert their own records in %', test_table_name;\n          END;\n          \n          -- Test 3b: User should NOT be able to insert records for other users\n          BEGIN\n            -- Note: Adapt this INSERT for your table structure\n            -- INSERT INTO test_table_name (user_id, data) VALUES (other_user, 'malicious data');\n            RAISE EXCEPTION 'SECURITY VIOLATION: User was able to insert records for other users in %', test_table_name;\n          EXCEPTION\n            WHEN insufficient_privilege THEN\n              RAISE NOTICE 'SECURITY TEST PASSED: User cannot insert records for other users in %', test_table_name;\n          END;\n          \n          -- Test 3c: User should NOT be able to update other users' records\n          BEGIN\n            -- Note: Adapt this UPDATE for your table structure\n            -- UPDATE test_table_name SET data = 'hacked' WHERE user_id = other_user;\n            \n            -- If we get here, check if any rows were actually affected\n            IF FOUND THEN\n              RAISE EXCEPTION 'SECURITY VIOLATION: User was able to update other users records in %', test_table_name;\n            ELSE\n              RAISE NOTICE 'SECURITY TEST PASSED: User cannot update other users records in %', test_table_name;\n            END IF;\n          EXCEPTION\n            WHEN insufficient_privilege THEN\n              RAISE NOTICE 'SECURITY TEST PASSED: User cannot update other users records in %', test_table_name;\n          END;\n        END $$;\n      ",
        "before_after_security_comparison": "\n        -- Security Preservation Test: Before/After Comparison\n        -- This test compares security behavior before and after optimization\n        \n        CREATE OR REPLACE FUNCTION test_policy_behavior(\n          p_table_name TEXT,\n          p_test_user UUID,\n          p_other_user UUID\n        ) RETURNS TABLE (\n          test_name TEXT,\n          before_optimization BOOLEAN,\n          after_optimization BOOLEAN,\n          security_preserved BOOLEAN\n        ) AS $$\n        DECLARE\n          before_count INTEGER;\n          after_count INTEGER;\n        BEGIN\n          -- Set user context\n          PERFORM set_config('request.jwt.claims', \n            json_build_object('sub', p_test_user, 'role', 'authenticated')::text, \n            true);\n          \n          -- Test: Count accessible records\n          EXECUTE format('SELECT COUNT(*) FROM %I', p_table_name) INTO after_count;\n          \n          -- For this test, we assume we have stored the \"before\" count somewhere\n          -- In a real implementation, you would run this test before optimization\n          -- and store the results for comparison\n          \n          RETURN QUERY SELECT \n            'Record Access Count'::TEXT,\n            true, -- before_optimization (placeholder)\n            (after_count > 0), -- after_optimization\n            true; -- security_preserved (would compare actual values)\n            \n          -- Add more specific tests here based on your table structure\n        END $$ LANGUAGE plpgsql;\n        \n        -- Example usage:\n        -- SELECT * FROM test_policy_behavior('projects', 'user-1'::UUID, 'user-2'::UUID);\n      "
      }
    },
    "role_based_tests": {
      "description": "Tests to verify role-based access controls work correctly",
      "tests": {
        "admin_role_test": "\n        -- Role-Based Security Test: Admin Access\n        -- Verifies that admin users have appropriate elevated access\n        \n        CREATE OR REPLACE FUNCTION verify_admin_access(p_table_name TEXT)\n        RETURNS TABLE (\n          table_name TEXT,\n          admin_can_select BOOLEAN,\n          admin_can_insert BOOLEAN,\n          admin_can_update BOOLEAN,\n          admin_can_delete BOOLEAN,\n          test_status TEXT\n        ) AS $$\n        DECLARE\n          test_admin UUID := 'test-admin-uuid'::UUID;\n          select_works BOOLEAN := false;\n          insert_works BOOLEAN := false;\n          update_works BOOLEAN := false;\n          delete_works BOOLEAN := false;\n        BEGIN\n          -- Set admin context\n          PERFORM set_config('request.jwt.claims', \n            json_build_object('sub', test_admin, 'role', 'admin')::text, \n            true);\n          \n          -- Test SELECT permission\n          BEGIN\n            EXECUTE format('SELECT COUNT(*) FROM %I', p_table_name);\n            select_works := true;\n          EXCEPTION\n            WHEN insufficient_privilege THEN\n              select_works := false;\n          END;\n          \n          -- Test INSERT permission (if applicable)\n          BEGIN\n            -- Note: This is a template - adapt for your table structure\n            -- EXECUTE format('INSERT INTO %I (user_id) VALUES (%L)', p_table_name, test_admin);\n            insert_works := true;\n          EXCEPTION\n            WHEN insufficient_privilege THEN\n              insert_works := false;\n          END;\n          \n          -- Test UPDATE permission (if applicable)\n          BEGIN\n            -- Note: This is a template - adapt for your table structure\n            -- EXECUTE format('UPDATE %I SET updated_at = NOW() WHERE user_id = %L', p_table_name, test_admin);\n            update_works := true;\n          EXCEPTION\n            WHEN insufficient_privilege THEN\n              update_works := false;\n          END;\n          \n          -- Test DELETE permission (if applicable)\n          BEGIN\n            -- Note: This is a template - adapt for your table structure\n            -- EXECUTE format('DELETE FROM %I WHERE user_id = %L AND created_at > NOW()', p_table_name, test_admin);\n            delete_works := true;\n          EXCEPTION\n            WHEN insufficient_privilege THEN\n              delete_works := false;\n          END;\n          \n          RETURN QUERY SELECT \n            p_table_name,\n            select_works,\n            insert_works,\n            update_works,\n            delete_works,\n            CASE \n              WHEN select_works THEN 'ADMIN_ACCESS_OK'\n              ELSE 'ADMIN_ACCESS_RESTRICTED'\n            END;\n        END $$ LANGUAGE plpgsql;\n      ",
        "regular_user_test": "\n        -- Role-Based Security Test: Regular User Access\n        -- Verifies that regular users have appropriate limited access\n        \n        CREATE OR REPLACE FUNCTION verify_user_access(p_table_name TEXT)\n        RETURNS TABLE (\n          table_name TEXT,\n          user_can_select_own BOOLEAN,\n          user_can_select_others BOOLEAN,\n          user_can_insert_own BOOLEAN,\n          user_can_insert_others BOOLEAN,\n          security_status TEXT\n        ) AS $$\n        DECLARE\n          test_user UUID := 'test-user-uuid'::UUID;\n          other_user UUID := 'other-user-uuid'::UUID;\n          own_records INTEGER := 0;\n          other_records INTEGER := 0;\n        BEGIN\n          -- Set regular user context\n          PERFORM set_config('request.jwt.claims', \n            json_build_object('sub', test_user, 'role', 'authenticated')::text, \n            true);\n          \n          -- Test: Can user see their own records?\n          BEGIN\n            EXECUTE format('SELECT COUNT(*) FROM %I WHERE user_id = %L', p_table_name, test_user) \n            INTO own_records;\n          EXCEPTION\n            WHEN insufficient_privilege THEN\n              own_records := -1; -- Indicates access denied\n          END;\n          \n          -- Test: Can user see other users' records? (They shouldn't be able to)\n          BEGIN\n            EXECUTE format('SELECT COUNT(*) FROM %I WHERE user_id = %L', p_table_name, other_user) \n            INTO other_records;\n          EXCEPTION\n            WHEN insufficient_privilege THEN\n              other_records := -1; -- Indicates access denied (good!)\n          END;\n          \n          RETURN QUERY SELECT \n            p_table_name,\n            (own_records >= 0), -- Can select own records\n            (other_records > 0), -- Can select others' records (should be false)\n            true, -- Placeholder for insert own\n            false, -- Placeholder for insert others\n            CASE \n              WHEN own_records >= 0 AND other_records = 0 THEN 'SECURITY_OK'\n              WHEN other_records > 0 THEN 'SECURITY_VIOLATION'\n              ELSE 'NEEDS_REVIEW'\n            END;\n        END $$ LANGUAGE plpgsql;\n      ",
        "cross_role_test": "\n        -- Role-Based Security Test: Cross-Role Access Verification\n        -- Compares access levels between different roles to ensure proper isolation\n        \n        CREATE OR REPLACE FUNCTION compare_role_access(p_table_name TEXT)\n        RETURNS TABLE (\n          table_name TEXT,\n          admin_record_count INTEGER,\n          user_record_count INTEGER,\n          manager_record_count INTEGER,\n          access_hierarchy_correct BOOLEAN,\n          security_assessment TEXT\n        ) AS $$\n        DECLARE\n          admin_count INTEGER := 0;\n          user_count INTEGER := 0;\n          manager_count INTEGER := 0;\n          test_user UUID := 'test-user-uuid'::UUID;\n        BEGIN\n          -- Test admin access\n          PERFORM set_config('request.jwt.claims', \n            json_build_object('sub', test_user, 'role', 'admin')::text, \n            true);\n          BEGIN\n            EXECUTE format('SELECT COUNT(*) FROM %I', p_table_name) INTO admin_count;\n          EXCEPTION\n            WHEN insufficient_privilege THEN admin_count := -1;\n          END;\n          \n          -- Test manager access\n          PERFORM set_config('request.jwt.claims', \n            json_build_object('sub', test_user, 'role', 'manager')::text, \n            true);\n          BEGIN\n            EXECUTE format('SELECT COUNT(*) FROM %I', p_table_name) INTO manager_count;\n          EXCEPTION\n            WHEN insufficient_privilege THEN manager_count := -1;\n          END;\n          \n          -- Test regular user access\n          PERFORM set_config('request.jwt.claims', \n            json_build_object('sub', test_user, 'role', 'authenticated')::text, \n            true);\n          BEGIN\n            EXECUTE format('SELECT COUNT(*) FROM %I', p_table_name) INTO user_count;\n          EXCEPTION\n            WHEN insufficient_privilege THEN user_count := -1;\n          END;\n          \n          RETURN QUERY SELECT \n            p_table_name,\n            admin_count,\n            user_count,\n            manager_count,\n            (admin_count >= manager_count AND manager_count >= user_count), -- Hierarchy check\n            CASE \n              WHEN admin_count >= manager_count AND manager_count >= user_count \n              THEN 'HIERARCHY_CORRECT'\n              ELSE 'HIERARCHY_VIOLATION'\n            END;\n        END $$ LANGUAGE plpgsql;\n      "
      }
    },
    "security_audits": {
      "description": "Comprehensive security audits comparing pre/post optimization",
      "audits": {
        "policy_change_audit": "\n        -- Security Audit: Policy Change Impact Assessment\n        -- This audit tracks what changed during optimization and assesses security impact\n        \n        CREATE OR REPLACE FUNCTION audit_policy_changes()\n        RETURNS TABLE (\n          table_name TEXT,\n          policy_name TEXT,\n          change_type TEXT,\n          original_qual TEXT,\n          optimized_qual TEXT,\n          original_with_check TEXT,\n          optimized_with_check TEXT,\n          security_impact_assessment TEXT,\n          requires_manual_review BOOLEAN\n        ) AS $$\n        BEGIN\n          -- Note: This function would need to be populated with actual before/after data\n          -- In a real implementation, you would store the original policies before optimization\n          \n          RETURN QUERY\n          SELECT \n            p.tablename::TEXT,\n            p.policyname::TEXT,\n            CASE \n              WHEN p.qual LIKE '%(SELECT auth.uid())%' OR p.qual LIKE '%(SELECT auth.jwt())%' \n              THEN 'OPTIMIZED'\n              WHEN p.qual LIKE '%auth.uid()%' OR p.qual LIKE '%auth.jwt()%'\n              THEN 'NEEDS_OPTIMIZATION'\n              ELSE 'NO_AUTH_CALLS'\n            END::TEXT,\n            p.qual::TEXT, -- This would be the optimized version\n            p.qual::TEXT, -- Placeholder - would be original version\n            p.with_check::TEXT, -- This would be the optimized version\n            p.with_check::TEXT, -- Placeholder - would be original version\n            CASE \n              WHEN p.qual LIKE '%(SELECT auth.uid())%' OR p.qual LIKE '%(SELECT auth.jwt())%'\n              THEN 'LOW_RISK - Optimization preserves security logic'\n              WHEN p.qual LIKE '%auth.uid()%' OR p.qual LIKE '%auth.jwt()%'\n              THEN 'MEDIUM_RISK - Policy needs optimization review'\n              ELSE 'NO_RISK - No auth function calls'\n            END::TEXT,\n            CASE \n              WHEN p.qual LIKE '%complex_condition%' THEN true\n              ELSE false\n            END\n          FROM pg_policies p\n          WHERE p.schemaname = 'public'\n          AND (p.qual LIKE '%auth.uid()%' OR p.qual LIKE '%auth.jwt()%' OR\n               p.with_check LIKE '%auth.uid()%' OR p.with_check LIKE '%auth.jwt()%');\n        END $$ LANGUAGE plpgsql;\n      ",
        "security_regression_audit": "\n        -- Security Audit: Regression Detection\n        -- This audit identifies potential security regressions after optimization\n        \n        CREATE OR REPLACE FUNCTION detect_security_regressions()\n        RETURNS TABLE (\n          table_name TEXT,\n          policy_name TEXT,\n          regression_type TEXT,\n          severity TEXT,\n          description TEXT,\n          recommended_action TEXT\n        ) AS $$\n        BEGIN\n          -- Check for policies that might have security issues after optimization\n          RETURN QUERY\n          SELECT \n            p.tablename::TEXT,\n            p.policyname::TEXT,\n            CASE \n              WHEN p.qual LIKE '%SELECT%SELECT%' THEN 'NESTED_SELECT'\n              WHEN p.qual LIKE '%((SELECT%' THEN 'DOUBLE_PARENTHESES'\n              WHEN p.qual IS NULL AND p.with_check IS NULL THEN 'EMPTY_POLICY'\n              ELSE 'UNKNOWN'\n            END::TEXT,\n            CASE \n              WHEN p.qual LIKE '%SELECT%SELECT%' THEN 'HIGH'\n              WHEN p.qual LIKE '%((SELECT%' THEN 'MEDIUM'\n              WHEN p.qual IS NULL AND p.with_check IS NULL THEN 'CRITICAL'\n              ELSE 'LOW'\n            END::TEXT,\n            CASE \n              WHEN p.qual LIKE '%SELECT%SELECT%' THEN 'Policy contains nested SELECT statements that may cause performance issues'\n              WHEN p.qual LIKE '%((SELECT%' THEN 'Policy contains double parentheses around SELECT that may cause syntax issues'\n              WHEN p.qual IS NULL AND p.with_check IS NULL THEN 'Policy has no conditions - allows unrestricted access'\n              ELSE 'No issues detected'\n            END::TEXT,\n            CASE \n              WHEN p.qual LIKE '%SELECT%SELECT%' THEN 'Review and fix nested SELECT statements'\n              WHEN p.qual LIKE '%((SELECT%' THEN 'Remove extra parentheses around SELECT statements'\n              WHEN p.qual IS NULL AND p.with_check IS NULL THEN 'Add appropriate access conditions to policy'\n              ELSE 'No action required'\n            END::TEXT\n          FROM pg_policies p\n          WHERE p.schemaname = 'public'\n          AND (\n            p.qual LIKE '%SELECT%SELECT%' OR \n            p.qual LIKE '%((SELECT%' OR\n            (p.qual IS NULL AND p.with_check IS NULL)\n          );\n        END $$ LANGUAGE plpgsql;\n      ",
        "comprehensive_security_validation": "\n        -- Security Audit: Comprehensive Validation\n        -- This audit provides a complete security assessment after optimization\n        \n        CREATE OR REPLACE FUNCTION comprehensive_security_validation()\n        RETURNS TABLE (\n          audit_category TEXT,\n          table_name TEXT,\n          policy_count INTEGER,\n          issues_found INTEGER,\n          security_score INTEGER,\n          status TEXT,\n          recommendations TEXT\n        ) AS $$\n        DECLARE\n          total_tables INTEGER;\n          tables_with_issues INTEGER;\n          overall_score INTEGER;\n        BEGIN\n          -- Count total tables with RLS policies\n          SELECT COUNT(DISTINCT tablename) INTO total_tables\n          FROM pg_policies \n          WHERE schemaname = 'public';\n          \n          -- Count tables with potential issues\n          SELECT COUNT(DISTINCT tablename) INTO tables_with_issues\n          FROM pg_policies \n          WHERE schemaname = 'public'\n          AND (\n            qual LIKE '%SELECT%SELECT%' OR \n            qual LIKE '%((SELECT%' OR\n            (qual IS NULL AND with_check IS NULL)\n          );\n          \n          -- Calculate overall security score\n          overall_score := CASE \n            WHEN total_tables = 0 THEN 0\n            ELSE ((total_tables - tables_with_issues) * 100 / total_tables)\n          END;\n          \n          -- Return summary by category\n          RETURN QUERY\n          SELECT \n            'OPTIMIZATION_SECURITY'::TEXT,\n            'ALL_TABLES'::TEXT,\n            total_tables,\n            tables_with_issues,\n            overall_score,\n            CASE \n              WHEN overall_score >= 95 THEN 'EXCELLENT'\n              WHEN overall_score >= 85 THEN 'GOOD'\n              WHEN overall_score >= 70 THEN 'ACCEPTABLE'\n              ELSE 'NEEDS_ATTENTION'\n            END::TEXT,\n            CASE \n              WHEN overall_score >= 95 THEN 'Security optimization completed successfully'\n              WHEN overall_score >= 85 THEN 'Minor issues detected - review recommended'\n              WHEN overall_score >= 70 THEN 'Some security issues found - address before production'\n              ELSE 'Significant security issues detected - immediate attention required'\n            END::TEXT;\n            \n          -- Add detailed breakdown by table (if needed)\n          -- Additional RETURN QUERY statements can be added here\n        END $$ LANGUAGE plpgsql;\n      "
      }
    }
  },
  "usage_instructions": {
    "before_optimization": [
      "Run baseline security tests to establish expected behavior",
      "Document current access patterns for each user role",
      "Store test results for comparison after optimization"
    ],
    "after_optimization": [
      "Execute all access pattern tests to verify behavior unchanged",
      "Run role-based tests to ensure proper access controls",
      "Execute security audits to detect any regressions",
      "Compare results with baseline to confirm security preservation"
    ],
    "ongoing_monitoring": [
      "Set up automated security tests in CI/CD pipeline",
      "Run security audits regularly to detect drift",
      "Monitor for new policies that need security verification"
    ]
  },
  "patterns_for_future_agents": {
    "secure_policy_development": {
      "description": "Patterns for developing new RLS policies with security best practices",
      "template": "\n          -- ✅ SECURE RLS Policy Development Pattern\n          -- Follow this pattern when creating new policies to ensure security\n          \n          -- 1. Always test with multiple user contexts\n          -- 2. Verify users can only access their own data\n          -- 3. Test role-based access controls\n          -- 4. Validate insert/update restrictions\n          \n          CREATE POLICY \"secure_policy_name\" ON \"table_name\"\n          AS PERMISSIVE FOR SELECT\n          TO authenticated\n          USING (\n            -- ✅ GOOD: User can only see their own records\n            user_id = (SELECT auth.uid())\n            \n            -- ✅ GOOD: Or admin can see all records\n            OR ((SELECT auth.jwt()) ->> 'role') = 'admin'\n            \n            -- ✅ GOOD: Or manager can see team records\n            OR (\n              ((SELECT auth.jwt()) ->> 'role') = 'manager'\n              AND team_id IN (\n                SELECT team_id FROM team_members \n                WHERE user_id = (SELECT auth.uid())\n              )\n            )\n          );\n        ",
      "security_tests": "\n          -- Security Test Template for New Policies\n          DO $$\n          DECLARE\n            test_user_1 UUID := gen_random_uuid();\n            test_user_2 UUID := gen_random_uuid();\n            admin_user UUID := gen_random_uuid();\n          BEGIN\n            -- Test 1: User isolation\n            SET request.jwt.claims TO json_build_object('sub', test_user_1, 'role', 'authenticated')::text;\n            -- Verify user can only see their own data\n            \n            -- Test 2: Admin access\n            SET request.jwt.claims TO json_build_object('sub', admin_user, 'role', 'admin')::text;\n            -- Verify admin can see appropriate data\n            \n            -- Test 3: Cross-user access prevention\n            SET request.jwt.claims TO json_build_object('sub', test_user_1, 'role', 'authenticated')::text;\n            -- Verify user cannot see other users' data\n          END $$;\n        "
    },
    "security_testing_workflow": {
      "description": "Workflow for testing security of new or modified policies",
      "steps": [
        "Create test users with different roles",
        "Test data access for each role",
        "Verify users cannot access unauthorized data",
        "Test insert/update/delete permissions",
        "Validate role hierarchy works correctly",
        "Run regression tests after changes"
      ]
    },
    "security_monitoring": {
      "description": "Ongoing security monitoring for RLS policies",
      "monitoring_queries": "\n          -- Daily Security Health Check\n          SELECT \n            COUNT(*) as total_policies,\n            COUNT(CASE WHEN qual IS NULL AND with_check IS NULL THEN 1 END) as unrestricted_policies,\n            COUNT(CASE WHEN qual LIKE '%auth.uid()%' OR qual LIKE '%auth.jwt()%' THEN 1 END) as auth_policies\n          FROM pg_policies \n          WHERE schemaname = 'public';\n        "
    }
  },
  "recommendations": [
    {
      "priority": "CRITICAL",
      "action": "Execute security tests before and after optimization",
      "description": "Run comprehensive security tests to ensure optimization preserves security behavior",
      "impact": "Prevents security regressions that could expose sensitive data"
    },
    {
      "priority": "HIGH",
      "action": "Implement automated security testing",
      "description": "Set up automated security tests in CI/CD pipeline for ongoing verification",
      "impact": "Catches security issues early in development process"
    },
    {
      "priority": "HIGH",
      "action": "Document security test results",
      "description": "Maintain records of security test results for audit and compliance",
      "impact": "Provides evidence of security due diligence"
    },
    {
      "priority": "MEDIUM",
      "action": "Train future agents on security patterns",
      "description": "Ensure future AI agents follow established security patterns",
      "impact": "Maintains consistent security standards across development"
    }
  ]
}