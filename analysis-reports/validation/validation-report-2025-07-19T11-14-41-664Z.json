{
  "title": "Comprehensive RLS Optimization Validation Report",
  "generated_at": "2025-07-19T11:14:41.656Z",
  "validation_queries": {
    "policy_optimization_status": "\n        -- RLS Policy Optimization Status by Table\n        -- This query shows the optimization status of all policies with auth function calls\n        \n        SELECT \n          tablename,\n          COUNT(*) as total_policies_with_auth,\n          \n          -- Count optimized policies (using SELECT subqueries)\n          COUNT(CASE \n            WHEN (qual LIKE '%(SELECT auth.uid())%' OR qual LIKE '%(SELECT auth.jwt())%' OR\n                  with_check LIKE '%(SELECT auth.uid())%' OR with_check LIKE '%(SELECT auth.jwt())%')\n            THEN 1 \n          END) as optimized_policies,\n          \n          -- Count policies needing optimization (direct calls)\n          COUNT(CASE \n            WHEN (qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(SELECT auth.uid())%') OR\n                 (qual LIKE '%auth.jwt()%' AND qual NOT LIKE '%(SELECT auth.jwt())%') OR\n                 (with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(SELECT auth.uid())%') OR\n                 (with_check LIKE '%auth.jwt()%' AND with_check NOT LIKE '%(SELECT auth.jwt())%')\n            THEN 1 \n          END) as policies_needing_optimization,\n          \n          -- Calculate optimization percentage\n          CASE \n            WHEN COUNT(*) > 0 THEN\n              ROUND(\n                COUNT(CASE \n                  WHEN (qual LIKE '%(SELECT auth.uid())%' OR qual LIKE '%(SELECT auth.jwt())%' OR\n                        with_check LIKE '%(SELECT auth.uid())%' OR with_check LIKE '%(SELECT auth.jwt())%')\n                  THEN 1 \n                END) * 100.0 / COUNT(*), 2\n              )\n            ELSE 0\n          END as optimization_percentage,\n          \n          -- Status classification\n          CASE \n            WHEN COUNT(CASE \n              WHEN (qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(SELECT auth.uid())%') OR\n                   (qual LIKE '%auth.jwt()%' AND qual NOT LIKE '%(SELECT auth.jwt())%') OR\n                   (with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(SELECT auth.uid())%') OR\n                   (with_check LIKE '%auth.jwt()%' AND with_check NOT LIKE '%(SELECT auth.jwt())%')\n              THEN 1 \n            END) = 0 THEN 'âœ… FULLY_OPTIMIZED'\n            WHEN COUNT(CASE \n              WHEN (qual LIKE '%(SELECT auth.uid())%' OR qual LIKE '%(SELECT auth.jwt())%' OR\n                    with_check LIKE '%(SELECT auth.uid())%' OR with_check LIKE '%(SELECT auth.jwt())%')\n              THEN 1 \n            END) > 0 THEN 'ðŸ”„ PARTIALLY_OPTIMIZED'\n            ELSE 'âŒ NOT_OPTIMIZED'\n          END as optimization_status\n          \n        FROM pg_policies \n        WHERE schemaname = 'public'\n        AND (\n          qual LIKE '%auth.uid()%' OR \n          qual LIKE '%auth.jwt()%' OR\n          with_check LIKE '%auth.uid()%' OR\n          with_check LIKE '%auth.jwt()%'\n        )\n        GROUP BY tablename\n        ORDER BY policies_needing_optimization DESC, tablename;\n      ",
    "nested_select_detection": "\n        -- Detect Problematic Nested SELECT Patterns\n        -- This query identifies policies that might have nested SELECT issues\n        \n        SELECT \n          tablename,\n          policyname,\n          cmd as policy_type,\n          \n          -- Check for problematic patterns in qual\n          CASE \n            WHEN qual LIKE '%SELECT%SELECT%' THEN 'NESTED_SELECT_IN_QUAL'\n            WHEN qual LIKE '%((SELECT%' THEN 'DOUBLE_PAREN_SELECT_IN_QUAL'\n            ELSE NULL\n          END as qual_issues,\n          \n          -- Check for problematic patterns in with_check\n          CASE \n            WHEN with_check LIKE '%SELECT%SELECT%' THEN 'NESTED_SELECT_IN_CHECK'\n            WHEN with_check LIKE '%((SELECT%' THEN 'DOUBLE_PAREN_SELECT_IN_CHECK'\n            ELSE NULL\n          END as with_check_issues,\n          \n          qual as condition_clause,\n          with_check as check_clause,\n          \n          -- Severity assessment\n          CASE \n            WHEN (qual LIKE '%SELECT%SELECT%' OR with_check LIKE '%SELECT%SELECT%') THEN 'HIGH'\n            WHEN (qual LIKE '%((SELECT%' OR with_check LIKE '%((SELECT%') THEN 'MEDIUM'\n            ELSE 'LOW'\n          END as issue_severity\n          \n        FROM pg_policies \n        WHERE schemaname = 'public'\n        AND (\n          qual LIKE '%SELECT%SELECT%' OR \n          with_check LIKE '%SELECT%SELECT%' OR\n          qual LIKE '%((SELECT%' OR \n          with_check LIKE '%((SELECT%'\n        )\n        ORDER BY \n          CASE issue_severity\n            WHEN 'HIGH' THEN 1\n            WHEN 'MEDIUM' THEN 2\n            ELSE 3\n          END,\n          tablename, policyname;\n      ",
    "before_after_comparison": "\n        -- Before/After Optimization Comparison Template\n        -- Use this query to compare policy states before and after optimization\n        \n        WITH policy_analysis AS (\n          SELECT \n            tablename,\n            policyname,\n            cmd,\n            qual,\n            with_check,\n            \n            -- Count direct auth calls (BEFORE optimization)\n            (LENGTH(COALESCE(qual, '')) - LENGTH(REPLACE(COALESCE(qual, ''), 'auth.uid()', ''))) / LENGTH('auth.uid()') +\n            (LENGTH(COALESCE(with_check, '')) - LENGTH(REPLACE(COALESCE(with_check, ''), 'auth.uid()', ''))) / LENGTH('auth.uid()') +\n            (LENGTH(COALESCE(qual, '')) - LENGTH(REPLACE(COALESCE(qual, ''), 'auth.jwt()', ''))) / LENGTH('auth.jwt()') +\n            (LENGTH(COALESCE(with_check, '')) - LENGTH(REPLACE(COALESCE(with_check, ''), 'auth.jwt()', ''))) / LENGTH('auth.jwt()') as total_direct_calls,\n            \n            -- Count optimized calls (AFTER optimization)\n            (LENGTH(COALESCE(qual, '')) - LENGTH(REPLACE(COALESCE(qual, ''), '(SELECT auth.uid())', ''))) / LENGTH('(SELECT auth.uid())') +\n            (LENGTH(COALESCE(with_check, '')) - LENGTH(REPLACE(COALESCE(with_check, ''), '(SELECT auth.uid())', ''))) / LENGTH('(SELECT auth.uid())') +\n            (LENGTH(COALESCE(qual, '')) - LENGTH(REPLACE(COALESCE(qual, ''), '(SELECT auth.jwt())', ''))) / LENGTH('(SELECT auth.jwt())') +\n            (LENGTH(COALESCE(with_check, '')) - LENGTH(REPLACE(COALESCE(with_check, ''), '(SELECT auth.jwt())', ''))) / LENGTH('(SELECT auth.jwt())') as total_optimized_calls,\n            \n            -- Optimization status\n            CASE \n              WHEN (qual LIKE '%(SELECT auth.uid())%' OR qual LIKE '%(SELECT auth.jwt())%' OR\n                    with_check LIKE '%(SELECT auth.uid())%' OR with_check LIKE '%(SELECT auth.jwt())%')\n              THEN 'OPTIMIZED'\n              WHEN (qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(SELECT auth.uid())%') OR\n                   (qual LIKE '%auth.jwt()%' AND qual NOT LIKE '%(SELECT auth.jwt())%') OR\n                   (with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(SELECT auth.uid())%') OR\n                   (with_check LIKE '%auth.jwt()%' AND with_check NOT LIKE '%(SELECT auth.jwt())%')\n              THEN 'NEEDS_OPTIMIZATION'\n              ELSE 'NO_AUTH_CALLS'\n            END as current_status\n            \n          FROM pg_policies \n          WHERE schemaname = 'public'\n        )\n        SELECT \n          tablename,\n          COUNT(*) as total_policies,\n          SUM(total_direct_calls) as total_direct_calls_found,\n          SUM(total_optimized_calls) as total_optimized_calls_found,\n          COUNT(CASE WHEN current_status = 'OPTIMIZED' THEN 1 END) as optimized_policies,\n          COUNT(CASE WHEN current_status = 'NEEDS_OPTIMIZATION' THEN 1 END) as policies_needing_optimization,\n          ROUND(\n            COUNT(CASE WHEN current_status = 'OPTIMIZED' THEN 1 END) * 100.0 / \n            NULLIF(COUNT(CASE WHEN current_status IN ('OPTIMIZED', 'NEEDS_OPTIMIZATION') THEN 1 END), 0), 2\n          ) as optimization_progress_percentage\n        FROM policy_analysis\n        WHERE current_status IN ('OPTIMIZED', 'NEEDS_OPTIMIZATION')\n        GROUP BY tablename\n        ORDER BY policies_needing_optimization DESC, tablename;\n      ",
    "validation_checklist": "\n        -- Comprehensive RLS Optimization Validation Checklist\n        -- This query provides a complete validation report\n        \n        WITH validation_metrics AS (\n          SELECT \n            -- Overall counts\n            COUNT(*) as total_policies_with_auth,\n            COUNT(CASE \n              WHEN (qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(SELECT auth.uid())%') OR\n                   (qual LIKE '%auth.jwt()%' AND qual NOT LIKE '%(SELECT auth.jwt())%') OR\n                   (with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(SELECT auth.uid())%') OR\n                   (with_check LIKE '%auth.jwt()%' AND with_check NOT LIKE '%(SELECT auth.jwt())%')\n              THEN 1 \n            END) as policies_with_direct_calls,\n            COUNT(CASE \n              WHEN (qual LIKE '%(SELECT auth.uid())%' OR qual LIKE '%(SELECT auth.jwt())%' OR\n                    with_check LIKE '%(SELECT auth.uid())%' OR with_check LIKE '%(SELECT auth.jwt())%')\n              THEN 1 \n            END) as policies_with_optimized_calls,\n            \n            -- Problem detection\n            COUNT(CASE \n              WHEN qual LIKE '%SELECT%SELECT%' OR with_check LIKE '%SELECT%SELECT%'\n              THEN 1 \n            END) as policies_with_nested_select,\n            COUNT(CASE \n              WHEN qual LIKE '%((SELECT%' OR with_check LIKE '%((SELECT%'\n              THEN 1 \n            END) as policies_with_double_paren_select\n            \n          FROM pg_policies \n          WHERE schemaname = 'public'\n          AND (\n            qual LIKE '%auth.uid()%' OR \n            qual LIKE '%auth.jwt()%' OR\n            with_check LIKE '%auth.uid()%' OR\n            with_check LIKE '%auth.jwt()%'\n          )\n        )\n        SELECT \n          'ðŸ“Š OPTIMIZATION VALIDATION REPORT' as report_section,\n          '' as separator,\n          \n          -- Validation results\n          CASE WHEN policies_with_direct_calls = 0 THEN 'âœ… PASS' ELSE 'âŒ FAIL' END as direct_calls_eliminated,\n          policies_with_direct_calls as remaining_direct_calls,\n          \n          CASE WHEN policies_with_optimized_calls > 0 THEN 'âœ… PASS' ELSE 'âŒ FAIL' END as optimizations_applied,\n          policies_with_optimized_calls as total_optimized_policies,\n          \n          CASE WHEN policies_with_nested_select = 0 THEN 'âœ… PASS' ELSE 'âš ï¸ WARNING' END as no_nested_select_issues,\n          policies_with_nested_select as nested_select_count,\n          \n          CASE WHEN policies_with_double_paren_select = 0 THEN 'âœ… PASS' ELSE 'âš ï¸ WARNING' END as no_double_paren_issues,\n          policies_with_double_paren_select as double_paren_count,\n          \n          -- Overall status\n          CASE \n            WHEN policies_with_direct_calls = 0 AND policies_with_optimized_calls > 0 \n            THEN 'ðŸŽ‰ OPTIMIZATION COMPLETE'\n            WHEN policies_with_direct_calls > 0 AND policies_with_optimized_calls > 0 \n            THEN 'ðŸ”„ OPTIMIZATION IN PROGRESS'\n            WHEN policies_with_direct_calls > 0 AND policies_with_optimized_calls = 0 \n            THEN 'âŒ OPTIMIZATION NOT STARTED'\n            ELSE 'â“ UNKNOWN STATUS'\n          END as overall_optimization_status,\n          \n          -- Progress percentage\n          CASE \n            WHEN total_policies_with_auth > 0 THEN\n              ROUND(policies_with_optimized_calls * 100.0 / total_policies_with_auth, 2)\n            ELSE 0\n          END as optimization_progress_percentage\n          \n        FROM validation_metrics;\n      "
  },
  "patterns_for_future_agents": {
    "new_policy_creation_pattern": {
      "description": "Template for creating new RLS policies that are already optimized",
      "template": "\n          -- âœ… OPTIMIZED RLS Policy Template for Future Development\n          -- Use this pattern when creating new policies to ensure they're already optimized\n          \n          CREATE POLICY \"policy_name\" ON \"table_name\"\n          AS PERMISSIVE FOR [SELECT|INSERT|UPDATE|DELETE]\n          TO authenticated\n          USING (\n            -- âœ… GOOD: Use subquery pattern for auth functions\n            user_id = (SELECT auth.uid())\n            AND status = 'active'\n            \n            -- âœ… GOOD: Complex conditions with optimized auth calls\n            OR (\n              role = 'admin' \n              AND ((SELECT auth.jwt()) ->> 'role') = 'admin'\n            )\n          )\n          WITH CHECK (\n            -- âœ… GOOD: Optimized auth calls in WITH CHECK clause\n            user_id = (SELECT auth.uid())\n            AND created_by = (SELECT auth.uid())\n          );\n        ",
      "anti_patterns": "\n          -- âŒ AVOID: Direct auth function calls (these need optimization)\n          \n          CREATE POLICY \"bad_policy\" ON \"table_name\"\n          USING (\n            user_id = auth.uid()  -- âŒ Direct call, needs optimization\n            AND (auth.jwt() ->> 'role') = 'admin'  -- âŒ Direct call, needs optimization\n          );\n        ",
      "validation_query": "\n          -- Use this query to validate new policies follow the optimized pattern\n          SELECT \n            policyname,\n            CASE \n              WHEN (qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(SELECT auth.uid())%') OR\n                   (qual LIKE '%auth.jwt()%' AND qual NOT LIKE '%(SELECT auth.jwt())%') OR\n                   (with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(SELECT auth.uid())%') OR\n                   (with_check LIKE '%auth.jwt()%' AND with_check NOT LIKE '%(SELECT auth.jwt())%')\n              THEN 'âŒ NEEDS_OPTIMIZATION'\n              WHEN (qual LIKE '%(SELECT auth.uid())%' OR qual LIKE '%(SELECT auth.jwt())%' OR\n                    with_check LIKE '%(SELECT auth.uid())%' OR with_check LIKE '%(SELECT auth.jwt())%')\n              THEN 'âœ… ALREADY_OPTIMIZED'\n              ELSE 'âšª NO_AUTH_CALLS'\n            END as optimization_status\n          FROM pg_policies \n          WHERE schemaname = 'public' \n          AND tablename = 'your_new_table_name';\n        "
    },
    "schema_migration_pattern": {
      "description": "Pattern for including RLS optimization in schema migrations",
      "template": "\n          -- Schema Migration with RLS Optimization Template\n          -- Use this pattern when creating new tables or modifying existing ones\n          \n          BEGIN;\n          \n          -- 1. Create or modify table schema\n          CREATE TABLE IF NOT EXISTS new_table (\n            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n            user_id UUID REFERENCES auth.users(id),\n            created_at TIMESTAMPTZ DEFAULT NOW(),\n            -- ... other columns\n          );\n          \n          -- 2. Enable RLS\n          ALTER TABLE new_table ENABLE ROW LEVEL SECURITY;\n          \n          -- 3. Create optimized policies from the start\n          CREATE POLICY \"new_table_select_policy\" ON \"new_table\"\n          AS PERMISSIVE FOR SELECT\n          TO authenticated\n          USING (user_id = (SELECT auth.uid()));  -- âœ… Already optimized\n          \n          CREATE POLICY \"new_table_insert_policy\" ON \"new_table\"\n          AS PERMISSIVE FOR INSERT\n          TO authenticated\n          WITH CHECK (user_id = (SELECT auth.uid()));  -- âœ… Already optimized\n          \n          -- 4. Validate optimization (optional check)\n          DO $$\n          BEGIN\n            IF EXISTS (\n              SELECT 1 FROM pg_policies \n              WHERE schemaname = 'public' \n              AND tablename = 'new_table'\n              AND (\n                (qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(SELECT auth.uid())%') OR\n                (qual LIKE '%auth.jwt()%' AND qual NOT LIKE '%(SELECT auth.jwt())%') OR\n                (with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(SELECT auth.uid())%') OR\n                (with_check LIKE '%auth.jwt()%' AND with_check NOT LIKE '%(SELECT auth.jwt())%')\n              )\n            ) THEN\n              RAISE EXCEPTION 'New policies contain unoptimized auth function calls';\n            END IF;\n          END $$;\n          \n          COMMIT;\n        "
    },
    "api_development_pattern": {
      "description": "Pattern for developing APIs that work efficiently with optimized RLS",
      "typescript_example": "\n          // âœ… GOOD: API Route with RLS Optimization Awareness\n          // This pattern ensures your API works efficiently with optimized RLS policies\n          \n          import { createClient } from '@supabase/supabase-js';\n          \n          export async function GET(request: Request) {\n            const supabase = createClient(url, key);\n            \n            // âœ… GOOD: Let RLS handle filtering efficiently\n            // The optimized policies will use (SELECT auth.uid()) efficiently\n            const { data, error } = await supabase\n              .from('your_table')\n              .select('*')\n              // Don't add manual user_id filtering - let RLS handle it\n              .order('created_at', { ascending: false });\n            \n            if (error) {\n              return Response.json({ error: error.message }, { status: 500 });\n            }\n            \n            return Response.json({ data });\n          }\n          \n          // âŒ AVOID: Manual filtering that duplicates RLS logic\n          export async function BAD_GET(request: Request) {\n            const supabase = createClient(url, key);\n            const { data: { user } } = await supabase.auth.getUser();\n            \n            // âŒ This duplicates what RLS already does efficiently\n            const { data, error } = await supabase\n              .from('your_table')\n              .select('*')\n              .eq('user_id', user?.id)  // âŒ Redundant with RLS\n              .order('created_at', { ascending: false });\n            \n            return Response.json({ data });\n          }\n        "
    },
    "testing_pattern": {
      "description": "Pattern for testing RLS policies to ensure they work correctly after optimization",
      "test_template": "\n          -- RLS Policy Testing Template\n          -- Use these queries to test that optimized policies work correctly\n          \n          -- Test 1: Verify policy exists and is optimized\n          SELECT \n            policyname,\n            cmd,\n            qual,\n            with_check,\n            CASE \n              WHEN (qual LIKE '%(SELECT auth.uid())%' OR qual LIKE '%(SELECT auth.jwt())%' OR\n                    with_check LIKE '%(SELECT auth.uid())%' OR with_check LIKE '%(SELECT auth.jwt())%')\n              THEN 'âœ… OPTIMIZED'\n              ELSE 'âŒ NOT_OPTIMIZED'\n            END as optimization_status\n          FROM pg_policies \n          WHERE schemaname = 'public' \n          AND tablename = 'test_table_name';\n          \n          -- Test 2: Verify policy behavior (run as different users)\n          -- This should be run in your application tests\n          SET ROLE authenticated;\n          SET request.jwt.claims TO '{\"sub\": \"user-id-1\", \"role\": \"authenticated\"}';\n          \n          -- Should return only records for user-id-1\n          SELECT * FROM test_table_name;\n          \n          -- Test 3: Performance test (check execution plan)\n          EXPLAIN (ANALYZE, BUFFERS) \n          SELECT * FROM test_table_name \n          WHERE created_at > NOW() - INTERVAL '1 day';\n        "
    },
    "monitoring_pattern": {
      "description": "Pattern for ongoing monitoring of RLS optimization status",
      "monitoring_queries": "\n          -- Daily RLS Optimization Health Check\n          -- Add this to your monitoring/alerting system\n          \n          WITH optimization_health AS (\n            SELECT \n              COUNT(*) as total_policies_with_auth,\n              COUNT(CASE \n                WHEN (qual LIKE '%auth.uid()%' AND qual NOT LIKE '%(SELECT auth.uid())%') OR\n                     (qual LIKE '%auth.jwt()%' AND qual NOT LIKE '%(SELECT auth.jwt())%') OR\n                     (with_check LIKE '%auth.uid()%' AND with_check NOT LIKE '%(SELECT auth.uid())%') OR\n                     (with_check LIKE '%auth.jwt()%' AND with_check NOT LIKE '%(SELECT auth.jwt())%')\n                THEN 1 \n              END) as unoptimized_policies\n            FROM pg_policies \n            WHERE schemaname = 'public'\n            AND (\n              qual LIKE '%auth.uid()%' OR \n              qual LIKE '%auth.jwt()%' OR\n              with_check LIKE '%auth.uid()%' OR\n              with_check LIKE '%auth.jwt()%'\n            )\n          )\n          SELECT \n            total_policies_with_auth,\n            unoptimized_policies,\n            CASE \n              WHEN unoptimized_policies = 0 THEN 'âœ… ALL_OPTIMIZED'\n              WHEN unoptimized_policies <= 5 THEN 'âš ï¸ MINOR_ISSUES'\n              ELSE 'âŒ OPTIMIZATION_NEEDED'\n            END as health_status,\n            ROUND(\n              (total_policies_with_auth - unoptimized_policies) * 100.0 / \n              NULLIF(total_policies_with_auth, 0), 2\n            ) as optimization_percentage\n          FROM optimization_health;\n        "
    }
  },
  "usage_instructions": {
    "for_current_optimization": [
      "Execute validation queries against your database to check optimization status",
      "Use the validation checklist to ensure all policies are properly optimized",
      "Run before/after comparison to measure optimization impact"
    ],
    "for_future_development": [
      "Follow the new policy creation pattern when adding tables",
      "Use the schema migration pattern for database changes",
      "Implement the API development pattern for efficient RLS usage",
      "Use the testing pattern to validate new policies",
      "Set up the monitoring pattern for ongoing health checks"
    ]
  },
  "recommendations": [
    {
      "priority": "HIGH",
      "action": "Execute validation queries regularly",
      "description": "Run the provided validation queries weekly to ensure optimization status",
      "impact": "Maintains performance benefits and catches regressions early"
    },
    {
      "priority": "HIGH",
      "action": "Enforce patterns in development workflow",
      "description": "Require future agents to follow the provided patterns for new features",
      "impact": "Prevents introduction of unoptimized policies"
    },
    {
      "priority": "MEDIUM",
      "action": "Set up automated monitoring",
      "description": "Implement the monitoring pattern in your CI/CD pipeline",
      "impact": "Automatic detection of optimization regressions"
    },
    {
      "priority": "MEDIUM",
      "action": "Create development guidelines",
      "description": "Document these patterns in your development standards",
      "impact": "Ensures consistent optimization across all future development"
    },
    {
      "priority": "LOW",
      "action": "Regular pattern updates",
      "description": "Review and update patterns as new requirements emerge",
      "impact": "Keeps optimization strategies current with evolving needs"
    }
  ]
}